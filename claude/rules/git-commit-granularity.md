# Git コミットの粒度

## 原則

小さなコミットは管理しやすい。後からスカッシュや並び替えはできるが、大きなコミットを分割するのは難しい。

## ルール

1. **1コミット1タイプ** - 各コミットは1つの Conventional Commits タイプのみ
   - 悪い例: バグ修正と新機能が1つのコミットに
   - 良い例: fix と feat を別々のコミットに

2. **迷ったら小さく** - 小さなコミットを作成し、必要に応じて後で統合

3. **論理的な単位** - 各コミットは1つの論理的な変更を表す

4. **コミット前に最新状態を確認** - コミット前に `git status` と `git diff` を実行して最新の変更を確認する（古いスナップショット情報に依存しない）

## なぜ小さなコミット？

- 複数のコミットを1つにスカッシュするのは簡単 (`git rebase -i`)
- コミットの並び替えは簡単 (`git rebase -i`)
- 特定の変更をチェリーピックするのは簡単
- 特定の変更を取り消すのは簡単
- 大きなコミットを小さく分割するのは難しい

## 例

### 良い例（小さく焦点を絞ったコミット）

```
feat(auth): ログインフォームコンポーネントを追加
feat(auth): ログイン API 呼び出しを追加
feat(auth): ログインエラーハンドリングを追加
test(auth): ログインテストを追加
```

### 悪い例（タイプ混在、大きすぎ）

```
feat(auth): テストとバグ修正を含むログイン機能を追加
```
